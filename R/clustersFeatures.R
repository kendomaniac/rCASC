#' @title A function to extract priority lists of genes from ANOVAlike output
#' @description This function extracts clusters specific gene lists from ANOVAlike output. IMPORTANT: This analysis works only on up modulated genes, i.e. genes more expressed in the clusters under analysis with respect to the reference cluster
#' @param group, a character string. Two options: sudo or docker, depending to which group the user belongs
#' @param data.folder, a character string indicating the folder where input data are located and where output will be written
#' @param logFC.table, a character string indicating the logFC_filtered_DE_ file generated by anovaLike function.
#' @param counts.table, a character string indicating the counts table file.
#' @param delta, in the minimal distance between the max value of FC for a gene in a cluster of interest and the nearest other max FC in any of the other clusters. This value define the minimal distance with respect to the same gene in an other cluster to identify it as a cluster specific gene.
#' @author Raffaele Calogero, raffaele.calogero [at] unito [dot] it, University of Torino
#' @return  Three tab delimited files file with prefix onlyUP\_, followed by the counts table name, i.e. the count table only containing the selected genes. onlyUP\_, followed by logFC_filtered_DE_,  the table containing logFC only for the selected genes, onlyUP_clusters_specific_genes.txt, which contains the list of specific genes associated with the corresponding cluster.
#'
#' @examples
#' \dontrun{
#' system("wget http://130.192.119.59/public/clusters.features.zip")
#' unzip("clusters.features.zip")
#' setwd("clusters.features")
#'
#'     clustersFeatures(group="docker", data.folder=getwd(),
#'         logFC.table="logFC_filtered_DE_annotated_setPace_10000_noC5_reordered.txt",
#'         counts.table="annotated_setPace_10000_noC5_reordered.txt", delta=0.5)
#' }
#'
#' @export
clustersFeatures <- function(group=c("sudo","docker"), data.folder, logFC.table, counts.table, delta=0.5){


  #storing the position of the home folder
  home <- getwd()

  #running time 1
  ptm <- proc.time()
  #setting the data.folder as working folder
  if (!file.exists(data.folder)){
    cat(paste("\nIt seems that the ",data.folder, " folder does not exist\n"))
    return(2)
  }

  setwd(data.folder)

  #initialize status
  system("echo 0 > ExitStatusFile 2>&1")

  de <- read.table(logFC.table, sep="\t", header=T, row.names = 1)
  selected.set <- NULL
  for(i in 1:dim(de)[2]){
       selected.set <- c(selected.set, which(de[,i] >= 1))
  }
  de.selected <- de[unique(selected.set),]

  #selecting the top candidates for separation between clusters
  # delta in de minimal distance between the max in cluster of interest and the nearest other max removing the cluster of interest
  .clusterGenes <- function(de.up, delta){
    max.de <- apply(de.up, 1, max)
    specific <- list()
    for(i in 1:dim(de.up)[2]){
      tmp <- as.numeric(de.up[,i] - max.de)#if column i has the max the delata with max is 0
      de.tmp0 <- de.up[which(tmp==0),]#selecting the data set for column i with max in that column
      max0.de <- apply(de.tmp0, 1, max)#max in de.tmp0
      de.tmp <- de.tmp0[, ! names(de.tmp0) %in% names(de.tmp0)[i], drop = F]#removing the column used to define max
      max1.de <- apply(de.tmp, 1, max)
      tmp.max <- as.numeric(max0.de - max1.de)#defining the distance between the max in column i and the nearest other max removing the column of interest

      specific[[names(de.up)[i]]] <- rownames(de.tmp0)[which(tmp.max>=delta)]
    }
    return(specific)
  }
  #set of cluster specific genes
  specifics <- .clusterGenes(de.selected, delta=delta)
  ###
  de.reorg <- list()
  for(i in 1:length(specifics)){
    de.reorg[[i]] <-  de.selected[which(rownames(de.selected)%in%specifics[[i]]),]
  }
  df <- do.call("rbind", de.reorg)


  write.table(df, paste("onlyUP_",logFC.table, sep=""), sep="\t", col.names = NA)
  ###
  counts <- read.table(counts.table, sep="\t", header=T, row.names = 1)
  counts.reorg <- list()
  for(i in 1:length(specifics)){
    counts.reorg[[i]] <- counts[which(rownames(counts)%in%specifics[[i]]),]
  }
  df.counts <- do.call("rbind", counts.reorg)
  write.table(df.counts, paste("onlyUP_",counts.table, sep=""), sep="\t", col.names = NA)
  ###
  specifics.reorg <- list()
  for(i in 1:length(specifics)){
    specifics.reorg[[i]] <-  data.frame(rep(names(specifics)[i], length(specifics[[i]])), specifics[[i]])
  }
  df.specific <- do.call("rbind", specifics.reorg)
  df.specific <- as.data.frame(df.specific)
  names(df.specific) <- c("cluster","geneID")
  write.table(df.specific, "onlyUP_clusters_specific_genes.txt", sep="\t", row.names = F)

    #running time 2
  ptm <- proc.time() - ptm
  dir <- dir(data.folder)
  dir <- dir[grep("run.info",dir)]
  if(length(dir)>0){
    con <- file("run.info", "r")
    tmp.run <- readLines(con)
    close(con)
    tmp.run[length(tmp.run)+1] <- paste("FastQC user run time mins ",ptm[1]/60, sep="")
    tmp.run[length(tmp.run)+1] <- paste("FastQC system run time mins ",ptm[2]/60, sep="")
    tmp.run[length(tmp.run)+1] <- paste("FastQC elapsed run time mins ",ptm[3]/60, sep="")
    writeLines(tmp.run,"run.info")
  }else{
    tmp.run <- NULL
    tmp.run[1] <- paste("FastQC user run time mins ",ptm[1]/60, sep="")
    tmp.run[length(tmp.run)+1] <- paste("FastQC system run time mins ",ptm[2]/60, sep="")
    tmp.run[length(tmp.run)+1] <- paste("FastQC elapsed run time mins ",ptm[3]/60, sep="")

    writeLines(tmp.run,"run.info")
  }

  #saving log and removing docker container

  system(paste("cp ",paste(path.package(package="casc"),"containers/containers.txt",sep="/")," ",data.folder, sep=""))
  setwd(home)
}
